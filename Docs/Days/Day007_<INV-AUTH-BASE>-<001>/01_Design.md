## Goal
이 티켓의 목표는 MMORPG 스타일 슬롯 기반 인벤토리의 최소 골격을 서버 Authority 기준으로 설계하는 것이다.
아이템 정의는 DataTable 기반으로 분리하고, 인벤토리는 캐릭터에 부착된 컴포넌트가 서버에서만 변경 권한을 가지도록 한다.
UI, 월드 픽업, 영속 저장(DB)은 범위에서 제외하고, 디버그 커맨드를 통해 아이템 추가/제거/조회가 네트워크 환경에서 일관되게 동작함을 검증한다.

## Class / Component Responsibilities

FItemDefRow (DataTable Row Struct)
- 아이템의 정적 정의 데이터를 보유
- ItemId(불변 식별자)를 기준으로 조회
- 이름, 타입(장비/소비/재료), 최대 스택 수 등 메타 정보만 포함
- 인벤토리 상태를 직접 보유하지 않음

FInventorySlot (Struct)
- 인벤토리의 단일 슬롯 상태 표현
- ItemId, Count를 보유
- 빈 슬롯은 ItemId = Invalid 상태로 표현
- 네트워크 복제 대상

UInventoryComponent
- 캐릭터에 부착되는 인벤토리 관리 컴포넌트
- 서버에서만 인벤토리 상태 변경
- 슬롯 배열(Slots)의 단일 변경 경로 제공
- 외부 시스템(퀘스트/업적/UI)을 위한 변경 이벤트 제공

주요 책임:
- 아이템 추가 / 제거 로직
- 슬롯 스택 합치기 및 빈 슬롯 탐색
- 인벤토리 상태 복제 및 변경 알림

Character (또는 테스트용 Owner)
- 인벤토리 컴포넌트를 소유
- 디버그용 Exec 함수 또는 입력을 통해 인벤토리 요청 수행
- 인벤토리 내부 로직에는 관여하지 않음

## Data Flow
아이템 추가(AddItem)
1.	클라이언트가 디버그 커맨드 또는 입력을 통해 아이템 추가 요청
2.	요청은 서버 RPC를 통해 서버로 전달
3.	서버는:
    - 유효한 ItemId인지 검증
    - 기존 슬롯에서 스택 가능한 슬롯 탐색
    - 남은 수량이 있으면 빈 슬롯에 배치
4.	서버에서 슬롯 배열을 변경
5.	슬롯 배열이 Replication을 통해 클라이언트로 동기화
6.	OnRep_Slots에서 인벤토리 변경 이벤트 브로드캐스트
7.	각 클라이언트에서 로그 또는 디버그 출력으로 결과 확인

아이템 제거(RemoveItem)
1.	클라이언트가 제거 요청
2.	서버에서:
    - 전체 슬롯을 순회하며 ItemId 일치 항목 차감
    - 수량 부족 시 실패 처리 (상태 변경 없음)
3.	성공 시 슬롯 배열 갱신 및 복제
4.	변경 이벤트 브로드캐스트

인벤토리 조회
	•	클라이언트는 로컬에 복제된 슬롯 데이터를 기반으로 조회
	•	서버 RPC 없이 읽기 전용 접근만 허용

## Edge Cases
- 아이템 추가 시:
    - 모든 슬롯이 가득 찬 경우 → 추가 실패
    - 최대 스택을 초과하는 경우 → 다음 슬롯으로 분산
- 아이템 제거 시:
    - 요청 수량보다 보유 수량이 적은 경우 → 전체 실패
- 네트워크:
    - 클라이언트가 직접 슬롯 배열을 수정하려는 시도는 무시
- 확장 시 고려:
    - 슬롯 스왑, 드래그 & 드롭은 별도 티켓으로 분리

## Perf / GC / Tick Notes
- Tick 사용 없음
- 인벤토리 변경은 이벤트 기반으로만 처리
- 슬롯 구조체는 값 타입으로 관리하여 GC 영향 최소화
- Actor 참조를 인벤토리에 직접 보관하지 않음
- 현재 슬롯 수가 적으므로 단순 배열 순회 허용 (대규모 확장 시 FastArraySerializer 검토)

## Replication Notes (선택)
- 슬롯 배열(Slots)은 서버 Authority 기준으로 Replicated
- 클라이언트는 상태를 “결과”로만 수신
- RepNotify에서 UI/퀘스트 시스템 연동 가능
- 추후 PlayerState로 이동 가능하도록 컴포넌트 의존성 최소화